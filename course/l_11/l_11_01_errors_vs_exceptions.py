"""Исключение - это ошибка, возникшая вне основного контекста выполнения. Например.
У тебя проект: ты лепишь куличик из песка, у тебя есть функции
набрать_песка_в_ведерко, утрамбовать_песок_, высыпать_песок.
Ты умеешь обрабатывать типовые ошибки этих функций: сломалось ведерко, погнулся совочек, кончился песочек.
Этого вроде достаточно, но тут под песочницей прорывает трубу с говном.
Это - исключительная ситуация, которую ловит обработчик исключений, а не основной цикл с тремя функциями.
Ты обрабатываешь исключение: с ревом убегаешь к маме утираться и больше не лезешь в программирование, пока не научишься
 в простейшие абстракции."""


#  Ошибки в коде программы можно разделить на три группы:

#  1) Синтаксические ошибки (приводит к немедленному завершению программы)
#  2) Ошибки времени выполнения (runtime errors) (тоже приводит к немедленному завершению программы)
#  3) Логические ошибки (не приводят к завершению программы)

# 1) Синткасические ошибки
# тут все просто - они происходят тогда, когда вы используете НЕ валидный синтаксис python
# Это ошибка выглядит так:
# SyntaxError: invalid syntax


# 2) Ошибки времени выполнения
# Этих ошибок очень много:
# - ZeroDivisionError (при попытке деления на 0)
# - ValueError (пример: вызов функции с не правльным типом аргумента)
# - AttributeError (при попытке обратиться к не существующему методу|атрибуту объекта)
# - ImportError (не удалось провести операцию импорт)
# - IndexError (при неверном указании индекса при срезе)
# - KeyError (При попытке получить объект по несуществующему ключу)
# - NameError (при попытке обратиться к не существующему идентификатору)
# - UnicodeError (ошибка связанная с кодировкой|раскодировкой строк)
# - TypeError (при попытке провести операцию с объектом, тип которого не поддерживает такие операции)
# - Exception (обозначает любую ошибку, по сути - является родителем всем другим типам ошибок
# )


def take_letter(obj, number):
    print('before error')
    letter = obj[number]  # оп и выпало исключение
    print('after error')
    return letter


word = 'try this Elon'

print(take_letter(word, 15))


# теперь обработаем его
def take_letter_safe(obj, number):
    print('before error')
    try:
        letter = obj[number]  # оп и выпало исключение
        return letter
    except IndexError as e:  # позволяет перехватить обработать и продолжить выполнение программы
        print('Error occurs in function take_letter_safe: ', e)
    print('Continue making mistakes')


# print(take_letter_safe(word, 1234))  # словили и вывели последний принт
print(take_letter_safe(word, 1))  # не вывели последний спринт


# нужно чтобы последний принт отпечатался
def take_letter_safe(obj, number):
    print('before error')
    try:
        letter = obj[number]  # оп и выпало исключение
        return letter
    except IndexError as e:  # позволяет перехватить обработать и продолжить выполнение программы
        print(e, 'not right index')
    finally:
        return (f'{obj} full word is here')


#  а можем создать своего ловца
def catch_me():
    try:
        take_letter(word, 43)
    except IndexError as e:
        print(f'got exception {e}')
    print('continue')


try:
    n = 42 / 0  # операция во время которой может быть вызвана ошибка
except ZeroDivisionError as e:  # после except - тип ошибки который мы ожидаем
    n = 0
except Exception as e:  # после except - тип ошибки который мы ожидаем
    print('Произошла ошибка!', e)
else:
    print('Тут не произошло ошибки')
finally:
    print('В конце концов это будет выполнено')
'''2. try/finally
Выполняет заключительные операции независимо от того , возникло исключение или нет.
'''

'''3. raise дает возможность возбудить исключение программно'''

'''4. whith/as реализует менеджеры контекста '''


# Логические ошибки
# Причина - не соответвие правильной логике программы


# Так же можно делать так:
def x1(*args):
    if len(args) < 5:
        raise ValueError("Слишком мало аргументов!")
    return args[4]


# Кроме механизма возбуждения ошибок, так же есть механизм утверждений:
# Используется во время тестирования
def x2(*args):
    assert len(args) < 5, "Слишком мало аргументов!"
    return args[4]


# Не соответствие утверждению вызввет AssertionError с сообщением которое идет после этого утверждения.
# Не стоит использовать утверждения в реально работающей программе как механизм вызова исключений,
# т.к. интерпритатор можно включить в таком режиме, что все утверждения будут игнорироваться
####
# Довольно часто просто обработать ошибку в функции - плохая затея.
# Необходимо, например, произвести логирование этой ошибки,
# и далее передать эту ошибку тому кто вызвал функцию.

# В таком случае обычно делают так:

def main(x):
    if x == 1:
        try:
            z = handle1()
        except Exception:
            z = handle2()


def handle1(*args):
    try:
        x = args[45]
        return
    except IndexError as e:
        print(f"Возникла ошибка!{e}")
        raise


def handle2(*args):
    try:
        x = args[4]
        return
    except IndexError as e:
        print(f"Возникла ошибка!{e}")
        raise

    # Эта команда опять вызовет то исключение, которые вы поймали!
    # Таким образом вы обработали ошибку в месте ее возникновения,
    # и дали знать тому кто вызвал функцию о том что произошла ошибка!


def finally_test():
    try:
        return 1
    finally:
        return 2  # return в finally всегда имеет больший приоритет.


print(finally_test())
